20190428-20190430
目的: tpuのコードをsbcl(common lisp)に移植する。
      (そのあとjuliaに移植したい)

1.  tpuのコードの特徴
変数、関数の宣言がすべてdefpropで、valueかexprのpropertyに設定するように書かれている
制御は、cond, go で書かれている。

本の付録Aには、概要と、各関数の簡単な説明があり、ソースコードと、例がいくつか書かれている。
テストを作れるくらい詳しい説明はないので、できるだけテストは書く(設計)が、最終的には
tpuの例(呼び出すformと結果)で確認する。

2. 変更方針
テストはtest-tpu.lispとして作成。(test.lispはLispWorkからもってきた)

condはよいが、goをどうするかで悩んだ。
sbcl.pdfでは、macroで変換後のgoを含むコードが書かれていて
それの見よう見まねでgoを書いてみたが、エラーになるだけなので
commonlispにはgoはないのかと思い、
途中まではループをloopに書き換えようとしていたが、
どのようなループになるのかわからなくって、deletevあたりでやめた。

deletevは、本の関数の概要のところに(X ∪ Y)-varだと書かれていたのでテストを作ったが、
結果のリストの順番あたりは実行結果にあわせた。
deletevのループは意味がわからなかったので、挫折。

実践COMMON LISPがなければ、なにも書けなかっただろう。
というわけで、実践をよんだら、commonlispでtagbodyを使えばgoが使えると
書かれていたので、そのあとはgoをそのままうつした。

そして4/30、tpuまでのコードを移し、tpuが最後まで動くようにはなったが
結果がまだおかしい。

ソースをタイプするとき、本のコピーを見て作業したわけだけれど、
コピーがきれいに読めないことと、
バスの中でタイプしていたので、見間違いも多く、どうもよくない。

8:15 これから、ソースをもう一度見直す。

ソースの間違いをいくつかみつけ、ex[567].lispの間違いも修正し
本と同じhistoryになった。
ex[89].lispも追加し、全exampleが通った。

[感想]
本をちゃんと読んでいないので、tpuのパラメタの4番目とか、意味を
わかっていない。
N1からN4については、終了条件。

証明は一回できてしまったら、何度も繰り返すものではないと思うので
こういう証明を作るためのパラメタというのは、カンニングみたいだ。
教科書として、このようなパラメタがあるのは理解できるが
実用の場合はどうすべきか













