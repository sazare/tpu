20190501
test-tpu.lispの充実
　できるだけ未作成のtest関数を作る。
　いくぶん仕様がはっきりする。ソースの意味がわからなくても。
　ex[1-9].lispをtest-ex[1-9].lispとして(test)を走らせるようにした。

  (stest u res) の仕様が奇妙なのはどうなっているのか。
  それはつまりsubsumeが必要なのかどうか

  (test )の名前で先頭にWEIRD:といれたのは、まだ仕様がよくわかっていないもの。

　juliaで動かそうと思っていたが、substがないのでめんどうだ。
  go をなくするのもめんどうだ。
　どうしたものか。
  tpuを作るメリットは??
　


20190428-20190430
目的: tpuのコードをsbcl(common lisp)に移植する。
      (そのあとjuliaに移植したい)

1.  tpuのコードの特徴
変数、関数の宣言がすべてdefpropで、valueかexprのpropertyに設定するように書かれている
制御は、cond, go で書かれている。

本の付録Aには、概要と、各関数の簡単な説明があり、ソースコードと、例がいくつか書かれている。
テストを作れるくらい詳しい説明はないので、できるだけテストは書く(設計)が、最終的には
tpuの例(呼び出すformと結果)で確認する。

2. 変更方針
テストはtest-tpu.lispとして作成。(test.lispはLispWorkからもってきた)

condはよいが、goをどうするかで悩んだ。
sbcl.pdfでは、macroで変換後のgoを含むコードが書かれていて
それの見よう見まねでgoを書いてみたが、エラーになるだけなので
commonlispにはgoはないのかと思い、
途中まではループをloopに書き換えようとしていたが、
どのようなループになるのかわからなくって、deletevあたりでやめた。

deletevは、本の関数の概要のところに(X ∪ Y)-varだと書かれていたのでテストを作ったが、
結果のリストの順番あたりは実行結果にあわせた。
deletevのループは意味がわからなかったので、挫折。

実践COMMON LISPがなければ、なにも書けなかっただろう。
というわけで、実践をよんだら、commonlispでtagbodyを使えばgoが使えると
書かれていたので、そのあとはgoをそのままうつした。

そして4/30、tpuまでのコードを移し、tpuが最後まで動くようにはなったが
結果がまだおかしい。

ソースをタイプするとき、本のコピーを見て作業したわけだけれど、
コピーがきれいに読めないことと、
バスの中でタイプしていたので、見間違いも多く、どうもよくない。

8:15 これから、ソースをもう一度見直す。

ソースの間違いをいくつかみつけ、ex[567].lispの間違いも修正し
本と同じhistoryになった。
ex[89].lispも追加し、全exampleが通った。

[感想]
本をちゃんと読んでいないので、tpuのパラメタの4番目とか、意味を
わかっていない。
N1からN4については、終了条件。

証明は一回できてしまったら、何度も繰り返すものではないと思うので
こういう証明を作るためのパラメタというのは、カンニングみたいだ。
教科書として、このようなパラメタがあるのは理解できるが
実用の場合はどうすべきか

[TPUのまとめ]
・代入は、S-式のsubst関数を使っているため、非常に簡単になっている。
・代入表現は順番に意味があるので、実際に適用するケースを考えないとどのような代入なのか明確ではない。
・subsumeで、同じclauseを削除して、爆発がおきないようにしている。
・原著の時期での実行時間が書いてあれば、今のPCでの実行時間との比較ができて面白いだろう。
・











